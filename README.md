# 2048ゲームのプログラム説明

- __やったこと：__

    2048ゲームを完成させて、オリジナルの要素を加えた。

 - __コードの説明：__

    - main.cについて：

        まず4つの関数を定義した。
        1. print_board関数は、縦N1 x 横N2の大きさの行列matの中身を表示する.
        for文で各要素の値をprintfしている。また、printfをする時に文字の色が赤色になるようにしている。

        2. number_0関数は、縦5 x 横5の大きさの行列matの要素が0である個数を数える関数である。
        for文で各要素が0であるかを調べ、ある要素の値が1であるなら、aに1ずつ加えている。

        3. same関数は、縦5 x 横5の大きさの行列mat1とmat2の全ての要素が等しいかを調べる。同じくfor文で各要素を回していて、mat1とmat2が等しい時は1, 等しくない時0がreturnされる。

        4. game_clear関数は、縦5 x 横5の大きさの行列matの要素に2048が含まれるかを調べる関数である。2048が含まれる時は1, 含まれない時0がreturnされる。

        次にmain関数について

        - 全体の方針
        
            (1) 5×5の配列を用意する。
            
            (2) キーボード入力によって、数字を移動させる。
            
            (3) 数字が0のところにランダムで2か４を発生させる。

            (4) 画面表示をする。
        
        - より詳細な説明

            (1) int型で5×5の配列mat_2048を準備する。このma_2048の初期値は、全ての要素が0である。

            (2) 
            
            - ' system("/bin/stty raw onlcr"); ' によって、enterを押さなくても、キー入力を受け付けるようにした。

            - int cでキーボード入力を受け取り、' . 'が押されない限り、while文の中身が実行されるようにした。
            キーボード入力は[↑][↓][→][←]で受け取れるようにした。ここでそれぞれの入力は、'A'、’B’、'C'、’D'に対応している
            。

            - [↑]を受け取った時：0行目から増やしていき、各行において0列目からfor分で回し、for文による現在位置において、その要素の値が2以上の時、新たなfor文で0のみを挟んだ上の行に同じ数字があれば、その上の行にあった数字が2倍される。そして、for文における元の位置の要素は1とする。1とした理由を述べる。例えば、t[2, 2, 4]という部分的な配列があった場合(tは転置を表す)、for文によって2行目の2は上の行に同じ数字があるため、t[4, 1, 4]となる。もし、元の位置を0にした場は、t[4, 0, 4]となり、for文で一番下の4まで行った時に上に4があるために足されてしまい、t[8, 0, 0]となる。よって、連続で数字が足されないようにするため、元の位置は1とする。

                そして、再び同じ順番でfor文を回して、ある要素が2以上で、0や1が上の行にある時は、上の行から2以上の数字が埋まるようにする。

                最後に、またfor文を使って、配列の要素のうち1であるものを0に変換している。

            - [↓]を受け取った時は、行う操作自体は同じであるが、数字が下詰めになるように、for文を回す順番を4行目から下げていき、各行において0列目から増やしている。また、要素の値が2以上の時は、1ずつ上にfor文を回して、等しい値があるかを調べている。

            - [←]を受け取った時は、数字が左詰めになるように、for文を回す順番は、0行目から増やし、その各行において0列目から増やしている。また、要素の値が2以上の時は、1ずつ左にfor文を回して、等しい値があるかを調べている。

            - [→]を受け取った時は、数字が右詰めになるように、for文を回す順番は、0行目から増やし、その各行において4列目から減らしている。また、要素の値が2以上の時は、1ずつ右にfor文を回して、等しい値があるかを調べている。

            (3) ' srand((unsigned int)time(NULL)); 'によって、異なる乱数列を得られるようにしている。int sはmat_2048の0の要素の個数を表しているため、乱数が入る可能性がある要素はs個であることと同値である。ここで配列中の0の場所を上から順に数字を割り当てる。sが1以上の時は、rand関数によって、0以上s未満の数字(int t)を発生させて、tを配列中の0に割り振った番号と対応させることで、配列中の要素が0であるものの内、ランダムな0の位置を決めることができる。これはfor文によって、配列の要素が0の時、tを1ずつ減らしていき、t = 0になった時に対応する0の位置ということである。そこに、rand関数を用いて、1か2を発生させ(int r)、rを2倍することで得られる2か4を代入する。
            もし、配列中に0がない時(s = 0)は、for文で、配列中の各要素の前後左右に同じ数字が並ぶかを調べ、int lifeによって、同じ数字がある時はlife ＝ 1、無い時はlife = 0となるようにする。life = 0の時は、どんなキーボード入力でも、配列の要素が0となるものが作れないから、t = -1として、ランダムな数字を発生させないようにしている。またランダムな数字が発生する条件として、ゲームの一番最初であるmat_2048が全て0の時(s = 25)、またはキーボード入力をする前後でmat_2048が変化しない時である。後者のキーボード入力をする前後でmat_2048が変化するかは、キーボード入力前にmat_2048をimitation_matにコピーして、キーボード入力後のmat_2048とimitation＿matを比較する。

            (4) ' system("clear"); 'によって画面をきれいにしてから、Press '.' to closeとYou pressed '%c'を表示する。また、mat_2048の要素に値2048が存在する時はClear!を、要素に0と2048が存在しない、かつ上で定めたlife = 0の時(隣り合う要素に同じ値がない時)はGame Over!が表示される。ターミナル上の文字の色は黄色である。
    
    - hatten.cについて

        hatten.cは、キーボード入力によって、行列のサイズを変更できるようにした。
        また、スペースキーを押すことによって1手だけ前の状態に戻せるようにした。
        
        - main.cからの変更点
            ' Choose the size of mat(Press more than 0)'が表示された後に、1以上の数字のキーボード入力する。それを数値(int w)に変換して、for文等の範囲をwを使って表した。

            main.cのimitation_matをimitation1_matとimitation2_matに分けた。imitation1_matはmat_2048のコピーであり、imitation2_matはimitation1_matのコピーである。ただし、imitation2_matは前の操作でmat_2048とimitation1_matが同じ時は、コピーされない。誤操作でmat_2048が何回か変わらない状況であっても(mat_2048の状態が変わらないのに、[↑]を連続して何回も押す等)、imitation2_matは、その状態の1つ前の異なる状態を保存するため、スペースキーで戻れる。
